// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CustomTagLookup Custom tag value
// swagger:model CustomTagLookup
type CustomTagLookup struct {

	// Flag that should be used to mark values that mean "not an issue" or "false positive".
	ConsideredIssue bool `json:"consideredIssue,omitempty"`

	// GUID of the parent custom tag this value belongs to.
	// Read Only: true
	CustomTagGUID string `json:"customTagGuid,omitempty"`

	// Flag that says if this value is default custom tag value and should be selected automatically in the values list on issue audit screen.
	DefaultValue bool `json:"defaultValue,omitempty"`

	// Flag that says if this value can be removed from custom tag. Value cannot be removed if it is selected for some issue in the system.
	// Read Only: true
	Deletable *bool `json:"deletable,omitempty"`

	// Custom tag value description.
	Description string `json:"description,omitempty"`

	// Flag that says that this value is hidden and cannot be selected in issue audit mode.
	Hidden bool `json:"hidden,omitempty"`

	// Current value index in values list.
	// Required: true
	LookupIndex *int32 `json:"lookupIndex"`

	// Plain text custom tag value.
	// Required: true
	LookupValue *string `json:"lookupValue"`

	// List of relying custom tags and their values this value depends on. This list should be set to automatically reflect relying custom tags values changes to this custom tag value
	RelyingCustomTags []*CustomTagInfo `json:"relyingCustomTags"`

	// Custom tag value sequence number.
	// Required: true
	SeqNumber *int32 `json:"seqNumber"`
}

// Validate validates this custom tag lookup
func (m *CustomTagLookup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLookupIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLookupValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelyingCustomTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeqNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustomTagLookup) validateLookupIndex(formats strfmt.Registry) error {

	if err := validate.Required("lookupIndex", "body", m.LookupIndex); err != nil {
		return err
	}

	return nil
}

func (m *CustomTagLookup) validateLookupValue(formats strfmt.Registry) error {

	if err := validate.Required("lookupValue", "body", m.LookupValue); err != nil {
		return err
	}

	return nil
}

func (m *CustomTagLookup) validateRelyingCustomTags(formats strfmt.Registry) error {

	if swag.IsZero(m.RelyingCustomTags) { // not required
		return nil
	}

	for i := 0; i < len(m.RelyingCustomTags); i++ {
		if swag.IsZero(m.RelyingCustomTags[i]) { // not required
			continue
		}

		if m.RelyingCustomTags[i] != nil {
			if err := m.RelyingCustomTags[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("relyingCustomTags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomTagLookup) validateSeqNumber(formats strfmt.Registry) error {

	if err := validate.Required("seqNumber", "body", m.SeqNumber); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustomTagLookup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustomTagLookup) UnmarshalBinary(b []byte) error {
	var res CustomTagLookup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
