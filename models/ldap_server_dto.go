// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LdapServerDto ldap server dto
// swagger:model LdapServerDto
type LdapServerDto struct {

	// attribute distinguished name
	// Required: true
	AttributeDistinguishedName *string `json:"attributeDistinguishedName"`

	// attribute email
	// Required: true
	AttributeEmail *string `json:"attributeEmail"`

	// attribute first name
	// Required: true
	AttributeFirstName *string `json:"attributeFirstName"`

	// attribute groupname
	// Required: true
	AttributeGroupname *string `json:"attributeGroupname"`

	// attribute last name
	// Required: true
	AttributeLastName *string `json:"attributeLastName"`

	// attribute member
	// Required: true
	AttributeMember *string `json:"attributeMember"`

	// attribute member of
	// Required: true
	AttributeMemberOf *string `json:"attributeMemberOf"`

	// attribute object class
	// Required: true
	AttributeObjectClass *string `json:"attributeObjectClass"`

	// attribute object sid
	AttributeObjectSid string `json:"attributeObjectSid,omitempty"`

	// attribute orgunit name
	// Required: true
	AttributeOrgunitName *string `json:"attributeOrgunitName"`

	// attribute password
	// Required: true
	AttributePassword *string `json:"attributePassword"`

	// attribute thumbnail mime default
	AttributeThumbnailMimeDefault string `json:"attributeThumbnailMimeDefault,omitempty"`

	// attribute thumbnail photo
	AttributeThumbnailPhoto string `json:"attributeThumbnailPhoto,omitempty"`

	// attribute user name
	// Required: true
	AttributeUserName *string `json:"attributeUserName"`

	// authenticator type
	// Required: true
	// Enum: [BIND_AUTHENTICATOR PASSWORD_COMPARISON_AUTHENTICATOR]
	AuthenticatorType *string `json:"authenticatorType"`

	// Distinguished name (DN) of root (base) LDAP entity SSC has access to. If value is set to not empty entity's DN, SSC has access only to this entity and all its children. If value of this attribute is an empty string, SSC has access to whole LDAP entities tree
	// Required: true
	BaseDn *string `json:"baseDn"`

	// base object sid
	BaseObjectSid string `json:"baseObjectSid,omitempty"`

	// cache enabled
	// Required: true
	CacheEnabled *bool `json:"cacheEnabled"`

	// cache eviction time
	// Required: true
	CacheEvictionTime *int32 `json:"cacheEvictionTime"`

	// cache executor pool size
	// Required: true
	CacheExecutorPoolSize *int32 `json:"cacheExecutorPoolSize"`

	// cache executor pool size max
	// Required: true
	CacheExecutorPoolSizeMax *int32 `json:"cacheExecutorPoolSizeMax"`

	// cache max threads per cache
	// Required: true
	CacheMaxThreadsPerCache *int32 `json:"cacheMaxThreadsPerCache"`

	// check ssl hostname
	// Required: true
	CheckSslHostname *bool `json:"checkSslHostname"`

	// check ssl trust
	// Required: true
	CheckSslTrust *bool `json:"checkSslTrust"`

	// class group
	// Required: true
	ClassGroup *string `json:"classGroup"`

	// class orgunit
	// Required: true
	ClassOrgunit *string `json:"classOrgunit"`

	// class user
	// Required: true
	ClassUser *string `json:"classUser"`

	// Boolean flag that marks LDAP server as default. Default means the server which configuration was imported from ldap.properties legacy configuration file
	// Required: true
	DefaultServer *bool `json:"defaultServer"`

	// Flag that marks server as enabled. All enabled servers are used by SSC. Server can be temporary disabled if it is temporary down.
	// Required: true
	Enabled *bool `json:"enabled"`

	// LDAP Server id
	// Required: true
	// Read Only: true
	ID int64 `json:"id"`

	// ignore partial result exception
	// Required: true
	IgnorePartialResultException *bool `json:"ignorePartialResultException"`

	// nested groups enabled
	// Required: true
	NestedGroupsEnabled *bool `json:"nestedGroupsEnabled"`

	// Version of the LDAP server entity to support editing LDAP server entity by multiply administrators
	// Required: true
	// Read Only: true
	ObjectVersion int32 `json:"objectVersion"`

	// page size
	// Required: true
	PageSize *int32 `json:"pageSize"`

	// paging enabled
	// Required: true
	PagingEnabled *bool `json:"pagingEnabled"`

	// password encoder type
	// Required: true
	// Enum: [NOT_SET LDAP_SHA_PASSWORD_ENCODER MD4_PASSWORD_ENCODER MD5_PASSWORD_ENCODER SHA_PASSWORD_ENCODER]
	PasswordEncoderType *string `json:"passwordEncoderType"`

	// referrals processing strategy
	// Required: true
	// Enum: [ignore follow]
	ReferralsProcessingStrategy *string `json:"referralsProcessingStrategy"`

	// save without validation
	SaveWithoutValidation bool `json:"saveWithoutValidation,omitempty"`

	// search Dns
	SearchDNS string `json:"searchDns,omitempty"`

	// Name of the LDAP server to distinguish it from other servers
	// Required: true
	ServerName *string `json:"serverName"`

	// url
	// Required: true
	URL *string `json:"url"`

	// user dn
	// Required: true
	UserDn *string `json:"userDn"`

	// user password
	// Required: true
	UserPassword *string `json:"userPassword"`

	// user photo enabled
	// Required: true
	UserPhotoEnabled *bool `json:"userPhotoEnabled"`

	// validation idle time
	// Required: true
	ValidationIdleTime *int32 `json:"validationIdleTime"`

	// validation time limit
	// Required: true
	ValidationTimeLimit *int32 `json:"validationTimeLimit"`
}

// Validate validates this ldap server dto
func (m *LdapServerDto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributeDistinguishedName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeGroupname(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeMember(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeMemberOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeObjectClass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeOrgunitName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttributeUserName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthenticatorType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBaseDn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheEvictionTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheExecutorPoolSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheExecutorPoolSizeMax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheMaxThreadsPerCache(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckSslHostname(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckSslTrust(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClassGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClassOrgunit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClassUser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultServer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIgnorePartialResultException(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNestedGroupsEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePagingEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePasswordEncoderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferralsProcessingStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserDn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserPhotoEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationIdleTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidationTimeLimit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapServerDto) validateAttributeDistinguishedName(formats strfmt.Registry) error {

	if err := validate.Required("attributeDistinguishedName", "body", m.AttributeDistinguishedName); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeEmail(formats strfmt.Registry) error {

	if err := validate.Required("attributeEmail", "body", m.AttributeEmail); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeFirstName(formats strfmt.Registry) error {

	if err := validate.Required("attributeFirstName", "body", m.AttributeFirstName); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeGroupname(formats strfmt.Registry) error {

	if err := validate.Required("attributeGroupname", "body", m.AttributeGroupname); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeLastName(formats strfmt.Registry) error {

	if err := validate.Required("attributeLastName", "body", m.AttributeLastName); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeMember(formats strfmt.Registry) error {

	if err := validate.Required("attributeMember", "body", m.AttributeMember); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeMemberOf(formats strfmt.Registry) error {

	if err := validate.Required("attributeMemberOf", "body", m.AttributeMemberOf); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeObjectClass(formats strfmt.Registry) error {

	if err := validate.Required("attributeObjectClass", "body", m.AttributeObjectClass); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeOrgunitName(formats strfmt.Registry) error {

	if err := validate.Required("attributeOrgunitName", "body", m.AttributeOrgunitName); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributePassword(formats strfmt.Registry) error {

	if err := validate.Required("attributePassword", "body", m.AttributePassword); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateAttributeUserName(formats strfmt.Registry) error {

	if err := validate.Required("attributeUserName", "body", m.AttributeUserName); err != nil {
		return err
	}

	return nil
}

var ldapServerDtoTypeAuthenticatorTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BIND_AUTHENTICATOR","PASSWORD_COMPARISON_AUTHENTICATOR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerDtoTypeAuthenticatorTypePropEnum = append(ldapServerDtoTypeAuthenticatorTypePropEnum, v)
	}
}

const (

	// LdapServerDtoAuthenticatorTypeBINDAUTHENTICATOR captures enum value "BIND_AUTHENTICATOR"
	LdapServerDtoAuthenticatorTypeBINDAUTHENTICATOR string = "BIND_AUTHENTICATOR"

	// LdapServerDtoAuthenticatorTypePASSWORDCOMPARISONAUTHENTICATOR captures enum value "PASSWORD_COMPARISON_AUTHENTICATOR"
	LdapServerDtoAuthenticatorTypePASSWORDCOMPARISONAUTHENTICATOR string = "PASSWORD_COMPARISON_AUTHENTICATOR"
)

// prop value enum
func (m *LdapServerDto) validateAuthenticatorTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ldapServerDtoTypeAuthenticatorTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerDto) validateAuthenticatorType(formats strfmt.Registry) error {

	if err := validate.Required("authenticatorType", "body", m.AuthenticatorType); err != nil {
		return err
	}

	// value enum
	if err := m.validateAuthenticatorTypeEnum("authenticatorType", "body", *m.AuthenticatorType); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateBaseDn(formats strfmt.Registry) error {

	if err := validate.Required("baseDn", "body", m.BaseDn); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCacheEnabled(formats strfmt.Registry) error {

	if err := validate.Required("cacheEnabled", "body", m.CacheEnabled); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCacheEvictionTime(formats strfmt.Registry) error {

	if err := validate.Required("cacheEvictionTime", "body", m.CacheEvictionTime); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCacheExecutorPoolSize(formats strfmt.Registry) error {

	if err := validate.Required("cacheExecutorPoolSize", "body", m.CacheExecutorPoolSize); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCacheExecutorPoolSizeMax(formats strfmt.Registry) error {

	if err := validate.Required("cacheExecutorPoolSizeMax", "body", m.CacheExecutorPoolSizeMax); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCacheMaxThreadsPerCache(formats strfmt.Registry) error {

	if err := validate.Required("cacheMaxThreadsPerCache", "body", m.CacheMaxThreadsPerCache); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCheckSslHostname(formats strfmt.Registry) error {

	if err := validate.Required("checkSslHostname", "body", m.CheckSslHostname); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateCheckSslTrust(formats strfmt.Registry) error {

	if err := validate.Required("checkSslTrust", "body", m.CheckSslTrust); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateClassGroup(formats strfmt.Registry) error {

	if err := validate.Required("classGroup", "body", m.ClassGroup); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateClassOrgunit(formats strfmt.Registry) error {

	if err := validate.Required("classOrgunit", "body", m.ClassOrgunit); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateClassUser(formats strfmt.Registry) error {

	if err := validate.Required("classUser", "body", m.ClassUser); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateDefaultServer(formats strfmt.Registry) error {

	if err := validate.Required("defaultServer", "body", m.DefaultServer); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", int64(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateIgnorePartialResultException(formats strfmt.Registry) error {

	if err := validate.Required("ignorePartialResultException", "body", m.IgnorePartialResultException); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateNestedGroupsEnabled(formats strfmt.Registry) error {

	if err := validate.Required("nestedGroupsEnabled", "body", m.NestedGroupsEnabled); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateObjectVersion(formats strfmt.Registry) error {

	if err := validate.Required("objectVersion", "body", int32(m.ObjectVersion)); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validatePageSize(formats strfmt.Registry) error {

	if err := validate.Required("pageSize", "body", m.PageSize); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validatePagingEnabled(formats strfmt.Registry) error {

	if err := validate.Required("pagingEnabled", "body", m.PagingEnabled); err != nil {
		return err
	}

	return nil
}

var ldapServerDtoTypePasswordEncoderTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NOT_SET","LDAP_SHA_PASSWORD_ENCODER","MD4_PASSWORD_ENCODER","MD5_PASSWORD_ENCODER","SHA_PASSWORD_ENCODER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerDtoTypePasswordEncoderTypePropEnum = append(ldapServerDtoTypePasswordEncoderTypePropEnum, v)
	}
}

const (

	// LdapServerDtoPasswordEncoderTypeNOTSET captures enum value "NOT_SET"
	LdapServerDtoPasswordEncoderTypeNOTSET string = "NOT_SET"

	// LdapServerDtoPasswordEncoderTypeLDAPSHAPASSWORDENCODER captures enum value "LDAP_SHA_PASSWORD_ENCODER"
	LdapServerDtoPasswordEncoderTypeLDAPSHAPASSWORDENCODER string = "LDAP_SHA_PASSWORD_ENCODER"

	// LdapServerDtoPasswordEncoderTypeMD4PASSWORDENCODER captures enum value "MD4_PASSWORD_ENCODER"
	LdapServerDtoPasswordEncoderTypeMD4PASSWORDENCODER string = "MD4_PASSWORD_ENCODER"

	// LdapServerDtoPasswordEncoderTypeMD5PASSWORDENCODER captures enum value "MD5_PASSWORD_ENCODER"
	LdapServerDtoPasswordEncoderTypeMD5PASSWORDENCODER string = "MD5_PASSWORD_ENCODER"

	// LdapServerDtoPasswordEncoderTypeSHAPASSWORDENCODER captures enum value "SHA_PASSWORD_ENCODER"
	LdapServerDtoPasswordEncoderTypeSHAPASSWORDENCODER string = "SHA_PASSWORD_ENCODER"
)

// prop value enum
func (m *LdapServerDto) validatePasswordEncoderTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ldapServerDtoTypePasswordEncoderTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerDto) validatePasswordEncoderType(formats strfmt.Registry) error {

	if err := validate.Required("passwordEncoderType", "body", m.PasswordEncoderType); err != nil {
		return err
	}

	// value enum
	if err := m.validatePasswordEncoderTypeEnum("passwordEncoderType", "body", *m.PasswordEncoderType); err != nil {
		return err
	}

	return nil
}

var ldapServerDtoTypeReferralsProcessingStrategyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ignore","follow"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ldapServerDtoTypeReferralsProcessingStrategyPropEnum = append(ldapServerDtoTypeReferralsProcessingStrategyPropEnum, v)
	}
}

const (

	// LdapServerDtoReferralsProcessingStrategyIgnore captures enum value "ignore"
	LdapServerDtoReferralsProcessingStrategyIgnore string = "ignore"

	// LdapServerDtoReferralsProcessingStrategyFollow captures enum value "follow"
	LdapServerDtoReferralsProcessingStrategyFollow string = "follow"
)

// prop value enum
func (m *LdapServerDto) validateReferralsProcessingStrategyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ldapServerDtoTypeReferralsProcessingStrategyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LdapServerDto) validateReferralsProcessingStrategy(formats strfmt.Registry) error {

	if err := validate.Required("referralsProcessingStrategy", "body", m.ReferralsProcessingStrategy); err != nil {
		return err
	}

	// value enum
	if err := m.validateReferralsProcessingStrategyEnum("referralsProcessingStrategy", "body", *m.ReferralsProcessingStrategy); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateServerName(formats strfmt.Registry) error {

	if err := validate.Required("serverName", "body", m.ServerName); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", m.URL); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateUserDn(formats strfmt.Registry) error {

	if err := validate.Required("userDn", "body", m.UserDn); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateUserPassword(formats strfmt.Registry) error {

	if err := validate.Required("userPassword", "body", m.UserPassword); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateUserPhotoEnabled(formats strfmt.Registry) error {

	if err := validate.Required("userPhotoEnabled", "body", m.UserPhotoEnabled); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateValidationIdleTime(formats strfmt.Registry) error {

	if err := validate.Required("validationIdleTime", "body", m.ValidationIdleTime); err != nil {
		return err
	}

	return nil
}

func (m *LdapServerDto) validateValidationTimeLimit(formats strfmt.Registry) error {

	if err := validate.Required("validationTimeLimit", "body", m.ValidationTimeLimit); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LdapServerDto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LdapServerDto) UnmarshalBinary(b []byte) error {
	var res LdapServerDto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
