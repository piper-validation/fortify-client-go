// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProjectVersionIssueDetails Application version issue details DTO object
// swagger:model Project version issue details
type ProjectVersionIssueDetails struct {

	// Vulnerability accuracy
	// Read Only: true
	Accuracy float32 `json:"accuracy,omitempty"`

	// Analyzer
	// Required: true
	Analyzer *string `json:"analyzer"`

	// A link to access application security training for this issue (available only if the SSC administrator has enabled it)
	// Read Only: true
	AppSecTrainingURL string `json:"appSecTrainingUrl,omitempty"`

	// User assigned to issue
	// Required: true
	AssignedUser *AssignedUser `json:"assignedUser"`

	// Attack payload
	// Required: true
	AttackPayload *string `json:"attackPayload"`

	// Attack type
	// Required: true
	// Enum: [URL REQUEST_HEADER REQUEST_COOKIE PARAMETER MULTIPLE]
	AttackType *string `json:"attackType"`

	// Attribute is set to true if issue is audited (primary tag values is set for this issue)
	// Required: true
	Audited *bool `json:"audited"`

	// Issue brief
	// Required: true
	Brief *string `json:"brief"`

	// Name of class where the vulnerability has been found
	// Read Only: true
	ClassName string `json:"className,omitempty"`

	// Issue confidence
	// Required: true
	Confidence *float32 `json:"confidence"`

	// Cookie
	// Required: true
	Cookie *string `json:"cookie"`

	// All the additional custom attributes defined for the issue by parser plugin
	// Read Only: true
	CustomAttributes interface{} `json:"customAttributes,omitempty"`

	// Custom tag values
	// Required: true
	CustomTagValues []*CustomTag `json:"customTagValues"`

	// Version of the issue data. This attribute is initialized only for issues parsed by 3rd party parsers and is not set for the issues parsed by standard parsers included in SSC installation.
	// Read Only: true
	DataVersion int32 `json:"dataVersion,omitempty"`

	// Issue detail
	// Required: true
	Detail *string `json:"detail"`

	// Display engine type
	// Required: true
	DisplayEngineType *string `json:"displayEngineType"`

	// Request contains binary or large data
	// Required: true
	DownloadRequest *bool `json:"downloadRequest"`

	// Response contains binary or large data"
	// Required: true
	DownloadResponse *bool `json:"downloadResponse"`

	// Engine category
	// Required: true
	// Enum: [STATIC DYNAMIC]
	EngineCategory *string `json:"engineCategory"`

	// Engine type
	// Required: true
	EngineType *string `json:"engineType"`

	// Issue found date
	// Required: true
	// Format: date-time
	FoundDate *Iso8601MilliDateTime `json:"foundDate"`

	// Fortify priority order (Friority)
	// Required: true
	Friority *string `json:"friority"`

	// Full file name where issue found
	// Required: true
	FullFileName *string `json:"fullFileName"`

	// Name of function located in the file where the vulnerability has been found
	// Read Only: true
	FunctionName string `json:"functionName,omitempty"`

	// Flag that indicates if there is a view template that should be used to display issue details on UI.
	// Read Only: true
	HasViewTemplate *bool `json:"hasViewTemplate,omitempty"`

	// Set to true if issue is hidden
	// Required: true
	Hidden *bool `json:"hidden"`

	// Identifier
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// Issue impact
	// Required: true
	Impact *float32 `json:"impact"`

	// Issue instance identifier
	// Required: true
	IssueInstanceID *string `json:"issueInstanceId"`

	// Name of the issue category
	// Required: true
	IssueName *string `json:"issueName"`

	// Flag represents issue state and says if issue is not an issue or open issue. Rule to calculate value of thi flag is defined in issue template.
	// Required: true
	IssueState *string `json:"issueState"`

	// Flag represents issue review status
	// Enum: [Unreviewed Under Review Reviewed]
	IssueStatus string `json:"issueStatus,omitempty"`

	// Issue kingdom
	// Required: true
	Kingdom *string `json:"kingdom"`

	// ID of the latest scan that found the issue
	LastScanID int64 `json:"lastScanId,omitempty"`

	// Issue likelihood
	// Required: true
	Likelihood *float32 `json:"likelihood"`

	// Line number in the file where the vulnerability has been found
	// Read Only: true
	LineNumber int32 `json:"lineNumber,omitempty"`

	// Name of the Fortify category of the vulnerability
	// Read Only: true
	MappedCategory string `json:"mappedCategory,omitempty"`

	// Method where issue found
	// Required: true
	Method *string `json:"method"`

	// Confidence level which estimates that vulnerability found in virtual (overridden) function will be executed by tainted source
	// Read Only: true
	MinVirtualCallConfidence float32 `json:"minVirtualCallConfidence,omitempty"`

	// Name of package where the vulnerability has been found
	// Read Only: true
	PackageName string `json:"packageName,omitempty"`

	// Primary rule global unique identifier
	// Required: true
	PrimaryRuleGUID *string `json:"primaryRuleGuid"`

	// Identifier, name and value of the custom tag that is selected as a primary tag for the application version the issue belongs to.
	PrimaryTag *IssuePrimaryTag `json:"primaryTag,omitempty"`

	// Vulnerability probability
	// Read Only: true
	Probability float32 `json:"probability,omitempty"`

	// Application version identifier
	// Required: true
	ProjectVersionID *int64 `json:"projectVersionId"`

	// Issue recommendation
	// Required: true
	Recommendation *string `json:"recommendation"`

	// References
	// Required: true
	References *string `json:"references"`

	// Level of complexity to fix this vulnerability
	// Read Only: true
	RemediationConstant float32 `json:"remediationConstant,omitempty"`

	// Issue removed date
	// Required: true
	// Format: date-time
	RemovedDate *Iso8601MilliDateTime `json:"removedDate"`

	// Request body
	// Required: true
	RequestBody *string `json:"requestBody"`

	// Request header
	// Required: true
	RequestHeader *string `json:"requestHeader"`

	// Request parameter
	// Required: true
	RequestParameter *string `json:"requestParameter"`

	// Triggers in the request
	// Read Only: true
	RequestTriggers []*Trigger `json:"requestTriggers"`

	// Response
	// Required: true
	Response *string `json:"response"`

	// Response header
	// Required: true
	ResponseHeader *string `json:"responseHeader"`

	// Triggers in the response
	// Read Only: true
	ResponseTriggers []*Trigger `json:"responseTriggers"`

	// Revision number
	// Required: true
	Revision *int32 `json:"revision"`

	// Scan status
	// Required: true
	ScanStatus *string `json:"scanStatus"`

	// Issue severity
	// Required: true
	Severity *float32 `json:"severity"`

	// Short file name where issue found
	// Required: true
	ShortFileName *string `json:"shortFileName"`

	// Taint sink name
	// Read Only: true
	Sink string `json:"sink,omitempty"`

	// Name of the context that contains vulnerability sink
	// Read Only: true
	SinkContext string `json:"sinkContext,omitempty"`

	// Name of the a program point where tainted data enter the program
	// Read Only: true
	Source string `json:"source,omitempty"`

	// Name of the context that contains vulnerability sources
	// Read Only: true
	SourceContext string `json:"sourceContext,omitempty"`

	// File name where vulnerability source is located.
	// Read Only: true
	SourceFile string `json:"sourceFile,omitempty"`

	// Line number in the source file where vulnerability source is located
	// Read Only: true
	SourceLine int32 `json:"sourceLine,omitempty"`

	// Set to true if issue is suppressed
	// Required: true
	Suppressed *bool `json:"suppressed"`

	// An attribute of tainted data that enables the data flow analyzer to discriminate between different types of taint
	// Read Only: true
	TaintFlag string `json:"taintFlag,omitempty"`

	// Issue tips
	// Required: true
	Tips *string `json:"tips"`

	// Issue trace nodes
	// Required: true
	TraceNodes [][]*TraceNodeDto `json:"traceNodes"`

	// Trigger string
	// Required: true
	TriggerString *string `json:"triggerString"`

	// Issue url
	// Required: true
	URL *string `json:"url"`

	// Vulnerable parameter
	// Required: true
	VulnerableParameter *string `json:"vulnerableParameter"`
}

// Validate validates this project version issue details
func (m *ProjectVersionIssueDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAnalyzer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssignedUser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttackPayload(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttackType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAudited(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBrief(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCookie(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomTagValues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayEngineType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadRequest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEngineCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEngineType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFoundDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFriority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFullFileName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHidden(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueInstanceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKingdom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLikelihood(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryRuleGUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryTag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectVersionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecommendation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferences(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemovedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestBody(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestParameter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestTriggers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseTriggers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRevision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScanStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortFileName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuppressed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTips(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTraceNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerString(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVulnerableParameter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectVersionIssueDetails) validateAnalyzer(formats strfmt.Registry) error {

	if err := validate.Required("analyzer", "body", m.Analyzer); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateAssignedUser(formats strfmt.Registry) error {

	if err := validate.Required("assignedUser", "body", m.AssignedUser); err != nil {
		return err
	}

	if m.AssignedUser != nil {
		if err := m.AssignedUser.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("assignedUser")
			}
			return err
		}
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateAttackPayload(formats strfmt.Registry) error {

	if err := validate.Required("attackPayload", "body", m.AttackPayload); err != nil {
		return err
	}

	return nil
}

var projectVersionIssueDetailsTypeAttackTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["URL","REQUEST_HEADER","REQUEST_COOKIE","PARAMETER","MULTIPLE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectVersionIssueDetailsTypeAttackTypePropEnum = append(projectVersionIssueDetailsTypeAttackTypePropEnum, v)
	}
}

const (

	// ProjectVersionIssueDetailsAttackTypeURL captures enum value "URL"
	ProjectVersionIssueDetailsAttackTypeURL string = "URL"

	// ProjectVersionIssueDetailsAttackTypeREQUESTHEADER captures enum value "REQUEST_HEADER"
	ProjectVersionIssueDetailsAttackTypeREQUESTHEADER string = "REQUEST_HEADER"

	// ProjectVersionIssueDetailsAttackTypeREQUESTCOOKIE captures enum value "REQUEST_COOKIE"
	ProjectVersionIssueDetailsAttackTypeREQUESTCOOKIE string = "REQUEST_COOKIE"

	// ProjectVersionIssueDetailsAttackTypePARAMETER captures enum value "PARAMETER"
	ProjectVersionIssueDetailsAttackTypePARAMETER string = "PARAMETER"

	// ProjectVersionIssueDetailsAttackTypeMULTIPLE captures enum value "MULTIPLE"
	ProjectVersionIssueDetailsAttackTypeMULTIPLE string = "MULTIPLE"
)

// prop value enum
func (m *ProjectVersionIssueDetails) validateAttackTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, projectVersionIssueDetailsTypeAttackTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProjectVersionIssueDetails) validateAttackType(formats strfmt.Registry) error {

	if err := validate.Required("attackType", "body", m.AttackType); err != nil {
		return err
	}

	// value enum
	if err := m.validateAttackTypeEnum("attackType", "body", *m.AttackType); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateAudited(formats strfmt.Registry) error {

	if err := validate.Required("audited", "body", m.Audited); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateBrief(formats strfmt.Registry) error {

	if err := validate.Required("brief", "body", m.Brief); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateConfidence(formats strfmt.Registry) error {

	if err := validate.Required("confidence", "body", m.Confidence); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateCookie(formats strfmt.Registry) error {

	if err := validate.Required("cookie", "body", m.Cookie); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateCustomTagValues(formats strfmt.Registry) error {

	if err := validate.Required("customTagValues", "body", m.CustomTagValues); err != nil {
		return err
	}

	for i := 0; i < len(m.CustomTagValues); i++ {
		if swag.IsZero(m.CustomTagValues[i]) { // not required
			continue
		}

		if m.CustomTagValues[i] != nil {
			if err := m.CustomTagValues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customTagValues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateDetail(formats strfmt.Registry) error {

	if err := validate.Required("detail", "body", m.Detail); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateDisplayEngineType(formats strfmt.Registry) error {

	if err := validate.Required("displayEngineType", "body", m.DisplayEngineType); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateDownloadRequest(formats strfmt.Registry) error {

	if err := validate.Required("downloadRequest", "body", m.DownloadRequest); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateDownloadResponse(formats strfmt.Registry) error {

	if err := validate.Required("downloadResponse", "body", m.DownloadResponse); err != nil {
		return err
	}

	return nil
}

var projectVersionIssueDetailsTypeEngineCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["STATIC","DYNAMIC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectVersionIssueDetailsTypeEngineCategoryPropEnum = append(projectVersionIssueDetailsTypeEngineCategoryPropEnum, v)
	}
}

const (

	// ProjectVersionIssueDetailsEngineCategorySTATIC captures enum value "STATIC"
	ProjectVersionIssueDetailsEngineCategorySTATIC string = "STATIC"

	// ProjectVersionIssueDetailsEngineCategoryDYNAMIC captures enum value "DYNAMIC"
	ProjectVersionIssueDetailsEngineCategoryDYNAMIC string = "DYNAMIC"
)

// prop value enum
func (m *ProjectVersionIssueDetails) validateEngineCategoryEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, projectVersionIssueDetailsTypeEngineCategoryPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProjectVersionIssueDetails) validateEngineCategory(formats strfmt.Registry) error {

	if err := validate.Required("engineCategory", "body", m.EngineCategory); err != nil {
		return err
	}

	// value enum
	if err := m.validateEngineCategoryEnum("engineCategory", "body", *m.EngineCategory); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateEngineType(formats strfmt.Registry) error {

	if err := validate.Required("engineType", "body", m.EngineType); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateFoundDate(formats strfmt.Registry) error {

	if err := validate.Required("foundDate", "body", m.FoundDate); err != nil {
		return err
	}

	if err := validate.FormatOf("foundDate", "body", "date-time", m.FoundDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateFriority(formats strfmt.Registry) error {

	if err := validate.Required("friority", "body", m.Friority); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateFullFileName(formats strfmt.Registry) error {

	if err := validate.Required("fullFileName", "body", m.FullFileName); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateHidden(formats strfmt.Registry) error {

	if err := validate.Required("hidden", "body", m.Hidden); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateImpact(formats strfmt.Registry) error {

	if err := validate.Required("impact", "body", m.Impact); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateIssueInstanceID(formats strfmt.Registry) error {

	if err := validate.Required("issueInstanceId", "body", m.IssueInstanceID); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateIssueName(formats strfmt.Registry) error {

	if err := validate.Required("issueName", "body", m.IssueName); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateIssueState(formats strfmt.Registry) error {

	if err := validate.Required("issueState", "body", m.IssueState); err != nil {
		return err
	}

	return nil
}

var projectVersionIssueDetailsTypeIssueStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unreviewed","Under Review","Reviewed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectVersionIssueDetailsTypeIssueStatusPropEnum = append(projectVersionIssueDetailsTypeIssueStatusPropEnum, v)
	}
}

const (

	// ProjectVersionIssueDetailsIssueStatusUnreviewed captures enum value "Unreviewed"
	ProjectVersionIssueDetailsIssueStatusUnreviewed string = "Unreviewed"

	// ProjectVersionIssueDetailsIssueStatusUnderReview captures enum value "Under Review"
	ProjectVersionIssueDetailsIssueStatusUnderReview string = "Under Review"

	// ProjectVersionIssueDetailsIssueStatusReviewed captures enum value "Reviewed"
	ProjectVersionIssueDetailsIssueStatusReviewed string = "Reviewed"
)

// prop value enum
func (m *ProjectVersionIssueDetails) validateIssueStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, projectVersionIssueDetailsTypeIssueStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProjectVersionIssueDetails) validateIssueStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.IssueStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateIssueStatusEnum("issueStatus", "body", m.IssueStatus); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateKingdom(formats strfmt.Registry) error {

	if err := validate.Required("kingdom", "body", m.Kingdom); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateLikelihood(formats strfmt.Registry) error {

	if err := validate.Required("likelihood", "body", m.Likelihood); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateMethod(formats strfmt.Registry) error {

	if err := validate.Required("method", "body", m.Method); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validatePrimaryRuleGUID(formats strfmt.Registry) error {

	if err := validate.Required("primaryRuleGuid", "body", m.PrimaryRuleGUID); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validatePrimaryTag(formats strfmt.Registry) error {

	if swag.IsZero(m.PrimaryTag) { // not required
		return nil
	}

	if m.PrimaryTag != nil {
		if err := m.PrimaryTag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("primaryTag")
			}
			return err
		}
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateProjectVersionID(formats strfmt.Registry) error {

	if err := validate.Required("projectVersionId", "body", m.ProjectVersionID); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRecommendation(formats strfmt.Registry) error {

	if err := validate.Required("recommendation", "body", m.Recommendation); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateReferences(formats strfmt.Registry) error {

	if err := validate.Required("references", "body", m.References); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRemovedDate(formats strfmt.Registry) error {

	if err := validate.Required("removedDate", "body", m.RemovedDate); err != nil {
		return err
	}

	if err := validate.FormatOf("removedDate", "body", "date-time", m.RemovedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRequestBody(formats strfmt.Registry) error {

	if err := validate.Required("requestBody", "body", m.RequestBody); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRequestHeader(formats strfmt.Registry) error {

	if err := validate.Required("requestHeader", "body", m.RequestHeader); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRequestParameter(formats strfmt.Registry) error {

	if err := validate.Required("requestParameter", "body", m.RequestParameter); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRequestTriggers(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestTriggers) { // not required
		return nil
	}

	for i := 0; i < len(m.RequestTriggers); i++ {
		if swag.IsZero(m.RequestTriggers[i]) { // not required
			continue
		}

		if m.RequestTriggers[i] != nil {
			if err := m.RequestTriggers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requestTriggers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateResponse(formats strfmt.Registry) error {

	if err := validate.Required("response", "body", m.Response); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateResponseHeader(formats strfmt.Registry) error {

	if err := validate.Required("responseHeader", "body", m.ResponseHeader); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateResponseTriggers(formats strfmt.Registry) error {

	if swag.IsZero(m.ResponseTriggers) { // not required
		return nil
	}

	for i := 0; i < len(m.ResponseTriggers); i++ {
		if swag.IsZero(m.ResponseTriggers[i]) { // not required
			continue
		}

		if m.ResponseTriggers[i] != nil {
			if err := m.ResponseTriggers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("responseTriggers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateRevision(formats strfmt.Registry) error {

	if err := validate.Required("revision", "body", m.Revision); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateScanStatus(formats strfmt.Registry) error {

	if err := validate.Required("scanStatus", "body", m.ScanStatus); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateSeverity(formats strfmt.Registry) error {

	if err := validate.Required("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateShortFileName(formats strfmt.Registry) error {

	if err := validate.Required("shortFileName", "body", m.ShortFileName); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateSuppressed(formats strfmt.Registry) error {

	if err := validate.Required("suppressed", "body", m.Suppressed); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateTips(formats strfmt.Registry) error {

	if err := validate.Required("tips", "body", m.Tips); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateTraceNodes(formats strfmt.Registry) error {

	if err := validate.Required("traceNodes", "body", m.TraceNodes); err != nil {
		return err
	}

	for i := 0; i < len(m.TraceNodes); i++ {

		for ii := 0; ii < len(m.TraceNodes[i]); ii++ {
			if swag.IsZero(m.TraceNodes[i][ii]) { // not required
				continue
			}

			if m.TraceNodes[i][ii] != nil {
				if err := m.TraceNodes[i][ii].Validate(formats); err != nil {
					if ve, ok := err.(*errors.Validation); ok {
						return ve.ValidateName("traceNodes" + "." + strconv.Itoa(i) + "." + strconv.Itoa(ii))
					}
					return err
				}
			}

		}

	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateTriggerString(formats strfmt.Registry) error {

	if err := validate.Required("triggerString", "body", m.TriggerString); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", m.URL); err != nil {
		return err
	}

	return nil
}

func (m *ProjectVersionIssueDetails) validateVulnerableParameter(formats strfmt.Registry) error {

	if err := validate.Required("vulnerableParameter", "body", m.VulnerableParameter); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProjectVersionIssueDetails) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectVersionIssueDetails) UnmarshalBinary(b []byte) error {
	var res ProjectVersionIssueDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
