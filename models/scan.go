// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Scan provides high-level information on the result of a single Fortify analysis, usually embedded inside an Artifact object
// swagger:model Scan
type Scan struct {

	// identifier of parent artifact object which contains this scan object
	// Required: true
	// Read Only: true
	ArtifactID int64 `json:"artifactId"`

	// optional string identifier provided by the user when scanning
	// Required: true
	// Read Only: true
	BuildID string `json:"buildId"`

	// optional string identifier provided by the user when scanning
	// Required: true
	// Read Only: true
	BuildLabel string `json:"buildLabel"`

	// optional string identifier provided by the user when scanning
	// Required: true
	// Read Only: true
	BuildProject string `json:"buildProject"`

	// optional string identifier provided by the user when scanning
	// Required: true
	// Read Only: true
	BuildVersion string `json:"buildVersion"`

	// indicates whether the checksum on the analysis result is valid
	// Required: true
	// Read Only: true
	Certification string `json:"certification"`

	// analysis duration
	// Required: true
	// Read Only: true
	ElapsedTime string `json:"elapsedTime"`

	// version of analysis engine
	// Required: true
	// Read Only: true
	EngineVersion string `json:"engineVersion"`

	// total executable lines of code included in sources (excluding comments etc.)
	// Required: true
	// Read Only: true
	ExecLOC int32 `json:"execLOC"`

	// lines of code with annotations
	// Required: true
	// Read Only: true
	FortifyAnnotationsLOC int32 `json:"fortifyAnnotationsLOC"`

	// globally unique id of scan object
	// Required: true
	// Read Only: true
	GUID string `json:"guid"`

	// hostname
	// Required: true
	// Read Only: true
	Hostname string `json:"hostname"`

	// id
	// Read Only: true
	ID int64 `json:"id,omitempty"`

	// number of source files included in scan
	// Required: true
	// Read Only: true
	NoOfFiles int32 `json:"noOfFiles"`

	// total lines of code included in sources (includes comments etc.)
	// Required: true
	// Read Only: true
	TotalLOC int32 `json:"totalLOC"`

	// indicates the type of analyzer that produced it, such as SCA or WEBINSPECT
	// Required: true
	// Read Only: true
	Type string `json:"type"`

	// upload date
	// Required: true
	// Read Only: true
	// Format: date-time
	UploadDate strfmt.DateTime `json:"uploadDate"`
}

// Validate validates this scan
func (m *Scan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateArtifactID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBuildVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCertification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateElapsedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEngineVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExecLOC(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFortifyAnnotationsLOC(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostname(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoOfFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalLOC(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUploadDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Scan) validateArtifactID(formats strfmt.Registry) error {

	if err := validate.Required("artifactId", "body", int64(m.ArtifactID)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateBuildID(formats strfmt.Registry) error {

	if err := validate.RequiredString("buildId", "body", string(m.BuildID)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateBuildLabel(formats strfmt.Registry) error {

	if err := validate.RequiredString("buildLabel", "body", string(m.BuildLabel)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateBuildProject(formats strfmt.Registry) error {

	if err := validate.RequiredString("buildProject", "body", string(m.BuildProject)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateBuildVersion(formats strfmt.Registry) error {

	if err := validate.RequiredString("buildVersion", "body", string(m.BuildVersion)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateCertification(formats strfmt.Registry) error {

	if err := validate.RequiredString("certification", "body", string(m.Certification)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateElapsedTime(formats strfmt.Registry) error {

	if err := validate.RequiredString("elapsedTime", "body", string(m.ElapsedTime)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateEngineVersion(formats strfmt.Registry) error {

	if err := validate.RequiredString("engineVersion", "body", string(m.EngineVersion)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateExecLOC(formats strfmt.Registry) error {

	if err := validate.Required("execLOC", "body", int32(m.ExecLOC)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateFortifyAnnotationsLOC(formats strfmt.Registry) error {

	if err := validate.Required("fortifyAnnotationsLOC", "body", int32(m.FortifyAnnotationsLOC)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateGUID(formats strfmt.Registry) error {

	if err := validate.RequiredString("guid", "body", string(m.GUID)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateHostname(formats strfmt.Registry) error {

	if err := validate.RequiredString("hostname", "body", string(m.Hostname)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateNoOfFiles(formats strfmt.Registry) error {

	if err := validate.Required("noOfFiles", "body", int32(m.NoOfFiles)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateTotalLOC(formats strfmt.Registry) error {

	if err := validate.Required("totalLOC", "body", int32(m.TotalLOC)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateType(formats strfmt.Registry) error {

	if err := validate.RequiredString("type", "body", string(m.Type)); err != nil {
		return err
	}

	return nil
}

func (m *Scan) validateUploadDate(formats strfmt.Registry) error {

	if err := validate.Required("uploadDate", "body", strfmt.DateTime(m.UploadDate)); err != nil {
		return err
	}

	if err := validate.FormatOf("uploadDate", "body", "date-time", m.UploadDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Scan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Scan) UnmarshalBinary(b []byte) error {
	var res Scan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
