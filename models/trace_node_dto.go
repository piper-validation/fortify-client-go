// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TraceNodeDto Issue analysis trace node DTO.
// swagger:model TraceNodeDto
type TraceNodeDto struct {

	// Child nodes of the current node.
	// Required: true
	// Read Only: true
	ChildNodes []*TraceNodeDto `json:"childNodes"`

	// Detail node marker.
	// Required: true
	// Read Only: true
	Detail bool `json:"detail"`

	// Node evidence text.
	// Required: true
	// Read Only: true
	Evidence string `json:"evidence"`

	// Name of the file associated with this node.
	// Required: true
	// Read Only: true
	File string `json:"file"`

	// Full path to source file associated with this node.
	// Required: true
	// Read Only: true
	FullPath string `json:"fullPath"`

	// Source file line number where issue was found.
	// Required: true
	// Read Only: true
	Line int32 `json:"line"`

	// Type of the trace node.
	// Required: true
	// Read Only: true
	// Enum: [IN_CALL OUT_CALL IN_OUT_CALL READ READ_GLOBAL ASSIGN ASSIGN_GLOBAL ALIAS COMPARE RETURN REF DEREF END_SCOPE JUMP BRANCH_TAKEN BRANCH_NOT_TAKEN EXTERNAL_ENTRY RUNTIME_SINK RUNTIME_SOURCE RUNTIME_VALIDATION RUNTIME_TRACE TRACE_RUNTIME_SOURCE TRACE_RUNTIME_SINK TAINT_CHANGE GENERIC]
	NodeType string `json:"nodeType"`

	// Primry node marker.
	// Required: true
	// Read Only: true
	Primary bool `json:"primary"`

	// Node display text.
	// Required: true
	// Read Only: true
	Text string `json:"text"`

	// Node description/tooltip.
	// Required: true
	// Read Only: true
	ToolTip string `json:"toolTip"`
}

// Validate validates this trace node dto
func (m *TraceNodeDto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChildNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFullPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLine(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateText(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToolTip(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TraceNodeDto) validateChildNodes(formats strfmt.Registry) error {

	if err := validate.Required("childNodes", "body", m.ChildNodes); err != nil {
		return err
	}

	for i := 0; i < len(m.ChildNodes); i++ {
		if swag.IsZero(m.ChildNodes[i]) { // not required
			continue
		}

		if m.ChildNodes[i] != nil {
			if err := m.ChildNodes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("childNodes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TraceNodeDto) validateDetail(formats strfmt.Registry) error {

	if err := validate.Required("detail", "body", bool(m.Detail)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateEvidence(formats strfmt.Registry) error {

	if err := validate.RequiredString("evidence", "body", string(m.Evidence)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateFile(formats strfmt.Registry) error {

	if err := validate.RequiredString("file", "body", string(m.File)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateFullPath(formats strfmt.Registry) error {

	if err := validate.RequiredString("fullPath", "body", string(m.FullPath)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateLine(formats strfmt.Registry) error {

	if err := validate.Required("line", "body", int32(m.Line)); err != nil {
		return err
	}

	return nil
}

var traceNodeDtoTypeNodeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IN_CALL","OUT_CALL","IN_OUT_CALL","READ","READ_GLOBAL","ASSIGN","ASSIGN_GLOBAL","ALIAS","COMPARE","RETURN","REF","DEREF","END_SCOPE","JUMP","BRANCH_TAKEN","BRANCH_NOT_TAKEN","EXTERNAL_ENTRY","RUNTIME_SINK","RUNTIME_SOURCE","RUNTIME_VALIDATION","RUNTIME_TRACE","TRACE_RUNTIME_SOURCE","TRACE_RUNTIME_SINK","TAINT_CHANGE","GENERIC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		traceNodeDtoTypeNodeTypePropEnum = append(traceNodeDtoTypeNodeTypePropEnum, v)
	}
}

const (

	// TraceNodeDtoNodeTypeINCALL captures enum value "IN_CALL"
	TraceNodeDtoNodeTypeINCALL string = "IN_CALL"

	// TraceNodeDtoNodeTypeOUTCALL captures enum value "OUT_CALL"
	TraceNodeDtoNodeTypeOUTCALL string = "OUT_CALL"

	// TraceNodeDtoNodeTypeINOUTCALL captures enum value "IN_OUT_CALL"
	TraceNodeDtoNodeTypeINOUTCALL string = "IN_OUT_CALL"

	// TraceNodeDtoNodeTypeREAD captures enum value "READ"
	TraceNodeDtoNodeTypeREAD string = "READ"

	// TraceNodeDtoNodeTypeREADGLOBAL captures enum value "READ_GLOBAL"
	TraceNodeDtoNodeTypeREADGLOBAL string = "READ_GLOBAL"

	// TraceNodeDtoNodeTypeASSIGN captures enum value "ASSIGN"
	TraceNodeDtoNodeTypeASSIGN string = "ASSIGN"

	// TraceNodeDtoNodeTypeASSIGNGLOBAL captures enum value "ASSIGN_GLOBAL"
	TraceNodeDtoNodeTypeASSIGNGLOBAL string = "ASSIGN_GLOBAL"

	// TraceNodeDtoNodeTypeALIAS captures enum value "ALIAS"
	TraceNodeDtoNodeTypeALIAS string = "ALIAS"

	// TraceNodeDtoNodeTypeCOMPARE captures enum value "COMPARE"
	TraceNodeDtoNodeTypeCOMPARE string = "COMPARE"

	// TraceNodeDtoNodeTypeRETURN captures enum value "RETURN"
	TraceNodeDtoNodeTypeRETURN string = "RETURN"

	// TraceNodeDtoNodeTypeREF captures enum value "REF"
	TraceNodeDtoNodeTypeREF string = "REF"

	// TraceNodeDtoNodeTypeDEREF captures enum value "DEREF"
	TraceNodeDtoNodeTypeDEREF string = "DEREF"

	// TraceNodeDtoNodeTypeENDSCOPE captures enum value "END_SCOPE"
	TraceNodeDtoNodeTypeENDSCOPE string = "END_SCOPE"

	// TraceNodeDtoNodeTypeJUMP captures enum value "JUMP"
	TraceNodeDtoNodeTypeJUMP string = "JUMP"

	// TraceNodeDtoNodeTypeBRANCHTAKEN captures enum value "BRANCH_TAKEN"
	TraceNodeDtoNodeTypeBRANCHTAKEN string = "BRANCH_TAKEN"

	// TraceNodeDtoNodeTypeBRANCHNOTTAKEN captures enum value "BRANCH_NOT_TAKEN"
	TraceNodeDtoNodeTypeBRANCHNOTTAKEN string = "BRANCH_NOT_TAKEN"

	// TraceNodeDtoNodeTypeEXTERNALENTRY captures enum value "EXTERNAL_ENTRY"
	TraceNodeDtoNodeTypeEXTERNALENTRY string = "EXTERNAL_ENTRY"

	// TraceNodeDtoNodeTypeRUNTIMESINK captures enum value "RUNTIME_SINK"
	TraceNodeDtoNodeTypeRUNTIMESINK string = "RUNTIME_SINK"

	// TraceNodeDtoNodeTypeRUNTIMESOURCE captures enum value "RUNTIME_SOURCE"
	TraceNodeDtoNodeTypeRUNTIMESOURCE string = "RUNTIME_SOURCE"

	// TraceNodeDtoNodeTypeRUNTIMEVALIDATION captures enum value "RUNTIME_VALIDATION"
	TraceNodeDtoNodeTypeRUNTIMEVALIDATION string = "RUNTIME_VALIDATION"

	// TraceNodeDtoNodeTypeRUNTIMETRACE captures enum value "RUNTIME_TRACE"
	TraceNodeDtoNodeTypeRUNTIMETRACE string = "RUNTIME_TRACE"

	// TraceNodeDtoNodeTypeTRACERUNTIMESOURCE captures enum value "TRACE_RUNTIME_SOURCE"
	TraceNodeDtoNodeTypeTRACERUNTIMESOURCE string = "TRACE_RUNTIME_SOURCE"

	// TraceNodeDtoNodeTypeTRACERUNTIMESINK captures enum value "TRACE_RUNTIME_SINK"
	TraceNodeDtoNodeTypeTRACERUNTIMESINK string = "TRACE_RUNTIME_SINK"

	// TraceNodeDtoNodeTypeTAINTCHANGE captures enum value "TAINT_CHANGE"
	TraceNodeDtoNodeTypeTAINTCHANGE string = "TAINT_CHANGE"

	// TraceNodeDtoNodeTypeGENERIC captures enum value "GENERIC"
	TraceNodeDtoNodeTypeGENERIC string = "GENERIC"
)

// prop value enum
func (m *TraceNodeDto) validateNodeTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, traceNodeDtoTypeNodeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TraceNodeDto) validateNodeType(formats strfmt.Registry) error {

	if err := validate.RequiredString("nodeType", "body", string(m.NodeType)); err != nil {
		return err
	}

	// value enum
	if err := m.validateNodeTypeEnum("nodeType", "body", m.NodeType); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validatePrimary(formats strfmt.Registry) error {

	if err := validate.Required("primary", "body", bool(m.Primary)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateText(formats strfmt.Registry) error {

	if err := validate.RequiredString("text", "body", string(m.Text)); err != nil {
		return err
	}

	return nil
}

func (m *TraceNodeDto) validateToolTip(formats strfmt.Registry) error {

	if err := validate.RequiredString("toolTip", "body", string(m.ToolTip)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TraceNodeDto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TraceNodeDto) UnmarshalBinary(b []byte) error {
	var res TraceNodeDto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
